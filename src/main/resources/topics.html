<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Topics in Java</title>
</head>
<body>
<h3><u>Topic in Java</u></h3><br>
<ol type="1">
    <li><b>Introduction to Git</b></li>
    <br>
    <li><b>Introduction to Programming</b></li>

    <ol type="1">
        <li>Types of languages</li>
        <li>Flowcharts & Pseudocode</li>
        <li>Flow of the program</li>
        <li>Time & Space Complexity</li>
    </ol>
    <li><i><b>Basics of Java</b></i>
        <br>
        <ol type="1">
            <li><b>Array</b></li>
            <ol type="I">
                <li>Introduction</li>
                <li>Memory management</li>
                <li>Input and Output</li>
                <li>ArrayList Introduction</li>
                <li>Sorting</li>
                <li>Insertion Sort</li>
                <li>Selection Sort</li>
                <li>Bubble Sort</li>
                <li>Count Sort</li>
                <li>Radix Sort</li>
                <li>Searching</li>
                <li>Linear Search</li>
                <li>Binary Search</li>
                <li>Modified Binary Search</li>
                <li>Two Pointer</li>
                <li>Subarray Questions
                </li>
            </ol>
            <br>
            <li><b><i>Strings</i></b></li>
            <ol type="I">
                <li>Introduction</li>
                <li>How Strings work</li>
                <li>Comparison of methods</li>
                <li>Operations in Strings</li>
                <li>StringBuilder in java</li>
            </ol>

            <br>
            <li><b><i>Maths for DSA</i></b></li>
            <ol type="I">
                <li>Introduction</li>
                <li>Complete Bitwise Operators</li>
                <li>Prime numbers</li>
                <li>HCF / LCM</li>
                <li>Sieve of Eratosthenes</li>
                <li>Newton's Square Root Method</li>
                <li>Number Theory</li>
                <li>Euclidean algorithm</li>
                <li>Advanced Concepts for CP (later in the course)</li>
                <li>Bitwise + DP</li>
                <li>Extended Euclidean algorithm</li>
                <li>Modulo Properties</li>
                <li>Modulo Multiplicative Inverse</li>
                <li>Linear Diophantine Equations</li>
                <li>Fermat’s Theorem</li>
                <li>Wilson's Theorem</li>
                <li>Lucas Theorem</li>
                <li>Chinese Remainder Theorem</li>
            </ol>
            <br>
            <li><b><i>Functions</i></b></li>
            <ol type="I">
                <li>Introduction</li>
                <li>Solving the above math problems in code</li>
                <li>Scoping in Java</li>
                <li>Shadowing</li>
                <li>Variable Length Arguments
            </ol>
            <br><b><i>
            <li> Recursion
        </i></b>
    </li>
    <ol type="I">
        <li>Introduction</li>
        <li>Why recursion?</li>
        <li>Flow of recursive programs - stacks</li>
        <li>Convert recursion to iteration</li>
        <li>Tree building of function calls
        <li>Tail recursion</li>
    </ol>
    <br><b><i>
    <li> Sorting:
</i></b>
    <ol type="I">
        <li>Merge Sort</li>
        <li>Quick Sort</li>
        <li>Cyclic Sort</li>

        <br><b></ol>
    <li>Backtracking</li>
    </i></b>
    <ol type="I">
        <li>Sudoku Solver</li>
        <li>N-Queens</li>
        <li>N-Knights</li>
        <li>Maze problems</li>
        <li>Recursion String Problems</li>
        <li>Recursion Array Problems</li>
        <li>Recursion Pattern Problems</li>
        <li>Subset Questions</li>
    </ol>
    <br><b><i>
    <li>Space and Time Complexity Analysis</li>
</i></b>
    <ol type="I">
        <li>Introduction</li>
        <li>Comparisons of various cases</li>
        <li>Solving Linear Recurrence Relations</li>
        <li>Solving Divide and Conquer Recurrence Relations</li>
        <li>Big-O, Big-Omega, Big-Theta Notations</li>
        <li>Get equation of any relation easily - best and easiest approach</li>
        <li>Complexity discussion of all the problems we do</li>
        <li>Space Complexity</li>
        <li>Memory Allocation of various languages</li>
        <li>NP-Completeness and Hardness</li>
    </ol>
    <br><b><i>
    <li>Object Oriented Programming</li>
</i></b>
    <ol type="I">

        <li>Introduction</li>
        <li>Classes & its instances</li>
        <li>this keyword in Java</li>
        <li>Properties</li>
        <li>Inheritance</li>
        <li>Abstraction</li>
        <li>Polymorphism</li>
        <li>Encapsulation</li>
        <li>Overloading & Overriding</li>
        <li>Static & Non-Static</li>
        <li>Access Control</li>
        <li>Interfaces</li>
        <li>Abstract Classes</li>
        <li>Singleton Class</li>
        <li>final, finalize, finally</li>
        <li>Exception Handling</li>
    </ol>
    <br><b><i>
    <li>Stacks & Queues</li>
</i></b>
    <ol type="I">
        <li>Introduction</li>
        <li>Interview problems</li>
        <li>Push efficient</li>
        <li>Pop efficient</li>
        <li>Queue using Stack and Vice versa</li>
        <li>Circular Queue</li>
    </ol>
    <br><b><i>
    <li>Linked List</li>
</i></b>
    <ol type="I">
        <li>Introduction</li>
        <li>Fast and slow pointer</li>
        <li>Cycle Detection</li>
        <li>Single and Doubly LinkedList</li>
        <li>Reversal of LinkedList</li>
    </ol>
    <br><b><i>
    <li>Dynamic Programming</li>
</i></b>
    <ol type="I">
        <li>Introduction</li>
        <li>Recursion + Recursion DP + Iteration + Iteration Space Optimized</li>
        <li>Complexity Analysis</li>
        <li>0/1 Knapsack</li>
        <li>Subset Questions</li>
        <li>Unbounded Knapsack</li>
        <li>Subsequence questions</li>
        <li>String DP</li>
    </ol>
    <br><b><i>
    <li>Trees</li>
</i></b>
    <ol type="I">
        <li>Introduction</li>
        <li>Binary Trees</li>
        <li>Binary Search Trees</li>
        <li>DFS</li>
        <li>BFS</li>
        <li>AVL Trees</li>
        <li>Segment Tree</li>
        <li>Fenwick Tree / Binary Indexed Tree</li>
        <li>Square Root Decomposition</li>
    </ol>
    <br><b><i>
    <li>Heaps</li>
</i></b>
    <ol type="I">
        <li>Introduction</li>
        <li>Theory</li>
        <li>Priority Queue</li>
        <li>Two Heaps Method</li>
        <li>k-way merge</li>
        <li>top k elements</li>
        <li>interval problems</li>
    </ol>
    <br><b><i>
    <li>HashMap</li>
</i></b>
    <ol type="I">
        <li>Introduction</li>
        <li>Theory - how it works</li>
        <li>Comparisons of various forms</li>
        <li>Limitations and how to solve</li>
        <li>Map using LinkedList</li>
        <li>Map using Hash</li>
        <li>Chaining</li>
        <li>Probing</li>
        <li>Huffman-Encoder</li>
        <li>Tries</li>
    </ol>
    <br><b><i>
    <li>Graphs</li>
</i></b>
    <ol type="I">
        <li>Introduction</li>
        <li>BFS</li>
        <li>DFS</li>
        <li>Working with graph components</li>
        <li>Minimum Spanning Trees</li>
        <li>Kruskal Algorithm</li>
        <li>Prims Algorithm</li>
        <li>Dijkstra’s shortest path algorithm</li>
        <li>Topological Sort</li>
        <li>Bellman ford</li>
        <li>A* pathfinding Algorithm</li>
    </ol>
</ol>
</li>
<br>
<br><b><i><u>
    What basic data structures and algorithms should one learn before starting competitive programming?
</u></i></b><br>
<ol type="1">
    <li>Basic data sturctures (arrays, queues, linked lists, etc.).</li>
    <li>Bit manipulation.</li>
    <li>Advanced data structures:</li>

    <ol type="A">
        <li>Union-Find Disjoint Sets.</li>
        <li>Segment Tree.</li>
        <li>Binary Indexed Tree (a.k.a Fenwik Tree).</li>
        <li>Graph.</li>
        <li>Tree</li>
        <li>Skip Lists.</li>
        <li>Some self balanced Binary Search trees (e.g. Red Black Trees).</li>
    </ol>

    <li>Brute force and it's tricks and advanced techniques (such as, pruning, bitmasks, meet in the middle,
        iterative deepining etc.)
    </li>
    <li> Binary Search (not only the basic code).</li>
    <li>Greedy.</li>
    <li> Dynamic programming and it's tricks and optimisations (Knuth optimisation, convex hull optimisation,
        bitmasks, etc.).
    </li>
    <li> Graph algorithms:</li>
    <ol type="A">
        <li> Traversal (DFS & BFS) algorithms and how to use them.</li>
        <li> Finding Connected Components.</li>
        <li> Flood Fill.</li>
        <li> Topological Sorting (the famous algorithm uses DFS but you should also know Kahn's algorithm that uses
            BFS as it has much applications).
        </li>
        <li> Bipartite Check.</li>
        <li> Finding Strongly Connected Components.</li>
        <li> Kruskal's and Prim's algorithms for finding the Minimum Spanning Tree of a graph and the variants of
            the problem.
        </li>
        <li> Dijkstra's algorithm for solving the Single Source Shortest Path (SSSP) Problem with out negaitive
            cycles.
        </li>
        <li> Bellman-Ford's algorithm for solving the SSSP problem with negative sycles.</li>
        <li> Floyd-Warshall's algorithm for solving the All Pairs Shortest Path (APSP) problem and it's variants.
        </li>
        <li> Network Flow problem (all it's algorithms, variants and the problems reducable to it). 9 Mathematics:
        </li>
        <li> You should be familiar with the BigInteger class in Java (maybe write your own if you are in love with
            C++).
        </li>
        <li> Some Combinatorics.</li>
        <li> Number Theory (all what you can learn about it).</li>
        <li> Probability Theory.</li>
        <li> Floyd-Cycle detection algorithm.</li>
        <li> Game Theory (especially impartial games and Sprague-Grundy Theorem).</li>
    </ol>
    <li> Strings:</li>

    <ol type="1"> Basic Manipulation.
        <li>Z-Algorithm for finding a pattern in a text.</li>
        <li> Knuth-Morris-Pratt Algorithm for finding a pattern in a text.</li>
        <li> Hashing and Rabin-Karp Algorithm for finding a pattern in a text.</li>
        <li>Trie data structure.</li>
        <li>Aho-Corasick Algorithm for finding multiple patterns in a text.</li>
        <li>Suffix Array data structure.</li>
        <li>Suffix Automaton data structure.</li>
        </li>
    </ol>
    <li> Computational Geometry Algorithms.</li>
</ol>
</ol>
</body>
</html>